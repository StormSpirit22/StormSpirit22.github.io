<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="二叉树简单题 #   上一篇文章里已经介绍了各种二叉树的遍历方式，可以看到对于二叉树来说，递归是最简洁并且好理解的遍历方式，所以对于二叉树的题，我们首先要想能不能用递归解决。而对于递归，我们不需要去考虑这个函数是否能实现我们要的功能，而是要相信函数一定能实现我们的功能，然后定义base case即可。学以致用，现在先来看看leetcode上二叉树的简单题，练练手。下面会先介绍这些题目的思路，ac代码集中放到最后。建议读者先自己去做一下想一想，然后手写代码，如果直接先看代码，没有经过自己的思考，第二次碰到可能还是不会做。
下面选取了一些题目，虽然是easy难度，但是如果是第一次做也是不容易能马上写出来的，所以还是要多刷题！^_^
 本文要介绍的题目有：
 二叉树的最大深度
 对称的二叉树
 二叉树的镜像
 二叉树的最近公共祖先
 平衡二叉树
 下面我们一个个来分析。
 二叉树的最大深度
 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
 解析：
这题比较简单，直接递归 max(left, right) &#43; 1即可。
 对称的二叉树
 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
 解析：
要判断是不是对称二叉树，并不是简单地递归去判断左右子树的值是否相等，比如第一个例子，到第二层的时候就不是判断左右子树的值相等了，而是需要判断 left.left.val == right.right.val 和 left.right.val == right.left.val。那这怎么做呢？我们可以用一个辅助函数，参数值是 left, right， 每次只要判断 left.val 是否等于 right.val ，然后再将 left.left 和 right.right， left.right 和 right.left 递归就好了。
 二叉树的镜像
 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
 解析：
这题就是使用前序遍历，先将root左右子树节点交换，然后再继续遍历。
 二叉树的最近公共祖先
 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="二叉树简单题" />
<meta property="og:description" content="二叉树简单题 #   上一篇文章里已经介绍了各种二叉树的遍历方式，可以看到对于二叉树来说，递归是最简洁并且好理解的遍历方式，所以对于二叉树的题，我们首先要想能不能用递归解决。而对于递归，我们不需要去考虑这个函数是否能实现我们要的功能，而是要相信函数一定能实现我们的功能，然后定义base case即可。学以致用，现在先来看看leetcode上二叉树的简单题，练练手。下面会先介绍这些题目的思路，ac代码集中放到最后。建议读者先自己去做一下想一想，然后手写代码，如果直接先看代码，没有经过自己的思考，第二次碰到可能还是不会做。
下面选取了一些题目，虽然是easy难度，但是如果是第一次做也是不容易能马上写出来的，所以还是要多刷题！^_^
 本文要介绍的题目有：
 二叉树的最大深度
 对称的二叉树
 二叉树的镜像
 二叉树的最近公共祖先
 平衡二叉树
 下面我们一个个来分析。
 二叉树的最大深度
 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
 解析：
这题比较简单，直接递归 max(left, right) &#43; 1即可。
 对称的二叉树
 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
 解析：
要判断是不是对称二叉树，并不是简单地递归去判断左右子树的值是否相等，比如第一个例子，到第二层的时候就不是判断左右子树的值相等了，而是需要判断 left.left.val == right.right.val 和 left.right.val == right.left.val。那这怎么做呢？我们可以用一个辅助函数，参数值是 left, right， 每次只要判断 left.val 是否等于 right.val ，然后再将 left.left 和 right.right， left.right 和 right.left 递归就好了。
 二叉树的镜像
 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
 解析：
这题就是使用前序遍历，先将root左右子树节点交换，然后再继续遍历。
 二叉树的最近公共祖先
 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E9%A2%98/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2021-05-22T15:18:39&#43;08:00" />
<meta property="article:modified_time" content="2021-05-22T15:18:39&#43;08:00" />

<title>二叉树简单题 | icestormspirit的博客</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.eacdd8a032b8d8235da73fc619c05c438feb17b4b2c5f1fa0a2dc66f27c2366b.css" integrity="sha256-6s3YoDK42CNdpz/GGcBcQ4/rF7SyxfH6Ci3GbyfCNms=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/zh.search.min.dc44d6a81f0edfa972725f6039da563a0760191b6696e848876dcca4895fb1e7.js" integrity="sha256-3ETWqB8O36lycl9gOdpWOgdgGRtmluhIh23MpIlfsec=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/"><span>icestormspirit的博客</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>Leetcode</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>二叉树</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="">二叉树遍历</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E9%A2%98/" class=" active">二叉树简单题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>链表</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Redis</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/redis/Redis%E5%AD%A6%E4%B9%A0%E4%B8%80/" class="">Redis学习（一）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="https://github.com/StormSpirit22/blog" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://themes.gohugo.io/hugo-book/" target="_blank" rel="noopener">
        Hugo Themes
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>二叉树简单题</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#二叉树简单题">二叉树简单题</a></li>
        <li><a href="#代码">代码</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="二叉树简单题">
  二叉树简单题
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%ae%80%e5%8d%95%e9%a2%98">#</a>
</h2>
<br/>
<p>上一篇文章里已经介绍了各种二叉树的遍历方式，可以看到对于二叉树来说，<strong>递归</strong>是最简洁并且好理解的遍历方式，所以对于二叉树的题，我们首先要想能不能用递归解决。而对于递归，我们不需要去考虑这个函数是否能实现我们要的功能，而是要<strong>相信</strong>函数一定能实现我们的功能，然后定义base case即可。学以致用，现在先来看看leetcode上二叉树的简单题，练练手。下面会先介绍这些题目的思路，ac代码集中放到最后。建议读者先自己去做一下想一想，然后手写代码，如果直接先看代码，没有经过自己的思考，第二次碰到可能还是不会做。</p>
<p>下面选取了一些题目，虽然是easy难度，但是如果是第一次做也是不容易能马上写出来的，所以还是要多刷题！^_^</p>
<br/>
<p>本文要介绍的题目有：</p>
<p>
  <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">平衡二叉树</a></p>
<br/>
<p>下面我们一个个来分析。</p>
<br/>
<p><strong>二叉树的最大深度</strong></p>
<blockquote>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p>解析：</p>
<p>这题比较简单，直接递归 max(left, right) + 1即可。</p>
<br/>
<p><strong>对称的二叉树</strong></p>
<blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
</blockquote>
<p>解析：</p>
<p>要判断是不是对称二叉树，并不是简单地递归去判断左右子树的值是否相等，比如第一个例子，到第二层的时候就不是判断左右子树的值相等了，而是需要判断 left.left.val == right.right.val 和 left.right.val == right.left.val。那这怎么做呢？我们可以用一个辅助函数，参数值是 left, right， 每次只要判断 left.val 是否等于 right.val ，然后再将 left.left 和 right.right， left.right 和 right.left 递归就好了。</p>
 <br/>
<p><strong>二叉树的镜像</strong></p>
<blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
</blockquote>
<p>解析：</p>
<p>这题就是使用前序遍历，先将root左右子树节点交换，然后再继续遍历。</p>
<br/>
<p><strong>二叉树的最近公共祖先</strong></p>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>解析：</p>
<p>我们在最开始就有说递归的思想就是要相信这个函数能实现我们的功能，然后定义base case。这题有几个base case需要判断，如果 root == nil 或 root == p 或 root == q，那么直接返回root，因为如果root是p或q中的任意一个节点，那么p、q的最近公共祖先肯定就是root。如果不是上述情况，那么p、q肯定在root的子树中。这样我们分别递归左右子树，返回的结果可以判断有三种情况，p、q都在root左子树中，则返回右子树的遍历结果，或者都在右子树中，返回左子树的遍历结果，或者p、q分别存在左右子树，则返回root。你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到。如果还是不理解，可以先看一下最后的代码，或者看一下官方的答案。</p>
<br/>
<p><strong>平衡二叉树</strong></p>
<blockquote>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
</blockquote>
<p>解析：</p>
<p>这题有两种解法，可以看题解。我这里选第二种解法来解释。我们可以先计算root节点的左子树的最大深度和右子树的最大深度，然后判断两者相差是否大于1，但是仅仅这样判断是不够的，因为你不知道左子树或者右子树里面会不会有深度相差大于1的情况，所以还需要继续递归左右子树去判断。</p>
<br/>
<h2 id="代码">
  代码
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81">#</a>
</h2>
<p><strong>二叉树的最大深度</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>), <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#a6e22e">b</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}
</code></pre></div><br/>
<p><strong>对称的二叉树</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isSymmetric</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">helper</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">helper</span>(<span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Val</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">helper</span>(<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Right</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">helper</span>(<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Left</span>)
}
</code></pre></div><br/>
<p><strong>二叉树的镜像</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mirrorTree</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> (<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
	}
	<span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>
	<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>
	<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">tmp</span>
	<span style="color:#a6e22e">mirrorTree</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
	<span style="color:#a6e22e">mirrorTree</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
}
</code></pre></div><br/>
<p><strong>二叉树的最近公共祖先</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">q</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
	}
	<span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span>)
	<span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">right</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>
}
</code></pre></div><br/>
<p><strong>平衡二叉树</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isBalanced</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }
    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> float64(<span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>))
    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> float64(<span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>))
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">left</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">right</span>) &gt; <span style="color:#ae81ff">1.0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">isBalanced</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">isBalanced</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>), <span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#a6e22e">b</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}

</code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#二叉树简单题">二叉树简单题</a></li>
        <li><a href="#代码">代码</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












