<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="二叉树中等题 #  上次已经做完了二叉树的简单题，这次来看看难度为中等的题。首先有一个点需要讲清楚，就是二叉树的解法基本都是通过遍历，那么如何判断我们应该用前序还是中序还是后序遍历的框架？根据题意，思考一个二叉树节点需要做什么，到底用什么遍历顺序就清楚了。先看题，最好先点到题目里做一遍。
本文要介绍的题目有：
 二叉树展开为链表
 填充每个节点的下一个右侧节点指针
 最大二叉树
 从前序与中序遍历序列构造二叉树
 从中序与后序遍历序列构造二叉树
 寻找重复的子树
下面我们一个个来分析。
 题目解析 #  二叉树展开为链表 #   给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。
 解析：
 想象一个最简单的情况，对于一个root节点来说，假设它的左右子树都只有一个节点，那么把树展开为链表，应该是先把root.Right保存下来，然后root.Right = root.Left，最后遍历新的右子树到它的最右节点，然后把之前的右子树接上去，这一块逻辑应该比较清晰。
 然后就是递归处理这一块代码就行了，有个问题就是这题用前序遍历还是后序呢？其实这两种都可以通过，区别在于需要的时间和空间不同，可以想象一下，如果是前序遍历，先将整个左子树拼接到右边，再去遍历整个右子树，整个右子树会拉得特别长，再一个个递归下去，这耗费的时间和空间就特别多了。而如果使用后序遍历，先遍历左右子树，分别把左右子树处理完成后，最后处理root节点，这样使用的时间和空间会少很多。即前序遍历是自顶向下的方法，而后序遍历是自底向上的方法，再通俗一点地说，对于这道题，使用后序遍历是使用归并的思想，先处理小的情况，最后把两边处理好的子树统一拼接起来，这样效率上会快很多。这个思路是递归的解法，迭代的解法可以去看官方解答。
 填充每个节点的下一个右侧节点指针 #   给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
 解析：
 这题同样也是想象一个最简单的情况，假设有这样一个前序遍历的二叉树，[1, 2, 3]，是不是非常简单，只需要把2节点的next指针指向3，即 left.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="二叉树中等题" />
<meta property="og:description" content="二叉树中等题 #  上次已经做完了二叉树的简单题，这次来看看难度为中等的题。首先有一个点需要讲清楚，就是二叉树的解法基本都是通过遍历，那么如何判断我们应该用前序还是中序还是后序遍历的框架？根据题意，思考一个二叉树节点需要做什么，到底用什么遍历顺序就清楚了。先看题，最好先点到题目里做一遍。
本文要介绍的题目有：
 二叉树展开为链表
 填充每个节点的下一个右侧节点指针
 最大二叉树
 从前序与中序遍历序列构造二叉树
 从中序与后序遍历序列构造二叉树
 寻找重复的子树
下面我们一个个来分析。
 题目解析 #  二叉树展开为链表 #   给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。
 解析：
 想象一个最简单的情况，对于一个root节点来说，假设它的左右子树都只有一个节点，那么把树展开为链表，应该是先把root.Right保存下来，然后root.Right = root.Left，最后遍历新的右子树到它的最右节点，然后把之前的右子树接上去，这一块逻辑应该比较清晰。
 然后就是递归处理这一块代码就行了，有个问题就是这题用前序遍历还是后序呢？其实这两种都可以通过，区别在于需要的时间和空间不同，可以想象一下，如果是前序遍历，先将整个左子树拼接到右边，再去遍历整个右子树，整个右子树会拉得特别长，再一个个递归下去，这耗费的时间和空间就特别多了。而如果使用后序遍历，先遍历左右子树，分别把左右子树处理完成后，最后处理root节点，这样使用的时间和空间会少很多。即前序遍历是自顶向下的方法，而后序遍历是自底向上的方法，再通俗一点地说，对于这道题，使用后序遍历是使用归并的思想，先处理小的情况，最后把两边处理好的子树统一拼接起来，这样效率上会快很多。这个思路是递归的解法，迭代的解法可以去看官方解答。
 填充每个节点的下一个右侧节点指针 #   给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
 解析：
 这题同样也是想象一个最简单的情况，假设有这样一个前序遍历的二叉树，[1, 2, 3]，是不是非常简单，只需要把2节点的next指针指向3，即 left." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AD%89%E9%A2%98/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2021-05-16T21:23:00&#43;08:00" />
<meta property="article:modified_time" content="2021-05-16T21:23:00&#43;08:00" />

<title>二叉树中等题 | icestormspirit的博客</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.eacdd8a032b8d8235da73fc619c05c438feb17b4b2c5f1fa0a2dc66f27c2366b.css" integrity="sha256-6s3YoDK42CNdpz/GGcBcQ4/rF7SyxfH6Ci3GbyfCNms=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/zh.search.min.1253f086b7a4d58073d0421f12919e3f9a171d56f0d2ec6e1d7f5898fc1e7406.js" integrity="sha256-ElPwhrek1YBz0EIfEpGeP5oXHVbw0uxuHX9YmPwedAY=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/"><span>icestormspirit的博客</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>Leetcode</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>二叉树</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="">二叉树遍历</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E9%A2%98/" class="">二叉树简单题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AD%89%E9%A2%98/" class=" active">二叉树中等题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E6%9D%82%E9%A2%98/" class="">二叉树复杂题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>链表</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/leetcode/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/" class="">数组</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Redis</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://StormSpirit22.github.io/docs/redis/Redis%E5%AD%A6%E4%B9%A0%E4%B8%80/" class="">Redis学习（一）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="https://github.com/StormSpirit22/blog" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://themes.gohugo.io/hugo-book/" target="_blank" rel="noopener">
        Hugo Themes
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>二叉树中等题</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#二叉树中等题">二叉树中等题</a>
      <ul>
        <li><a href="#题目解析">题目解析</a>
          <ul>
            <li><a href="#二叉树展开为链表">二叉树展开为链表</a></li>
            <li><a href="#填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</a></li>
            <li><a href="#最大二叉树">最大二叉树</a></li>
            <li><a href="#从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</a></li>
            <li><a href="#从中序与后序遍历序列构造二叉树">从中序与后序遍历序列构造二叉树</a></li>
            <li><a href="#寻找重复的子树">寻找重复的子树</a></li>
          </ul>
        </li>
        <li><a href="#代码">代码</a>
          <ul>
            <li><a href="#二叉树展开为链表-1">二叉树展开为链表</a></li>
            <li><a href="#填充每个节点的下一个右侧节点指针-1">填充每个节点的下一个右侧节点指针</a></li>
            <li><a href="#最大二叉树-1">最大二叉树</a></li>
            <li><a href="#从前序与中序遍历序列构造二叉树-1">从前序与中序遍历序列构造二叉树</a></li>
            <li><a href="#从中序与后序遍历序列构造二叉树-1">从中序与后序遍历序列构造二叉树</a></li>
            <li><a href="#寻找重复的子树-1">寻找重复的子树</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="二叉树中等题">
  二叉树中等题
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e7%ad%89%e9%a2%98">#</a>
</h1>
<br>
<p>上次已经做完了二叉树的简单题，这次来看看难度为中等的题。首先有一个点需要讲清楚，就是二叉树的解法基本都是通过遍历，<strong>那么如何判断我们应该用前序还是中序还是后序遍历的框架</strong>？<strong>根据题意，思考一个二叉树节点需要做什么，到底用什么遍历顺序就清楚了</strong>。先看题，最好先点到题目里做一遍。</p>
<br>
<p>本文要介绍的题目有：</p>
<p>
  <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/maximum-binary-tree/">最大二叉树</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></p>
<p>
  <a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">寻找重复的子树</a></p>
<p>下面我们一个个来分析。</p>
<br/>
<h2 id="题目解析">
  题目解析
  <a class="anchor" href="#%e9%a2%98%e7%9b%ae%e8%a7%a3%e6%9e%90">#</a>
</h2>
<h3 id="二叉树展开为链表">
  二叉树展开为链表
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e5%b1%95%e5%bc%80%e4%b8%ba%e9%93%be%e8%a1%a8">#</a>
</h3>
<blockquote>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
</blockquote>
<p>解析：</p>
<p>    想象一个最简单的情况，对于一个root节点来说，假设它的左右子树都只有一个节点，那么把树展开为链表，应该是先把root.Right保存下来，然后root.Right = root.Left，最后遍历新的右子树到它的最右节点，然后把之前的右子树接上去，这一块逻辑应该比较清晰。</p>
<p>    然后就是递归处理这一块代码就行了，有个问题就是这题用前序遍历还是后序呢？其实这两种都可以通过，区别在于需要的时间和空间不同，可以想象一下，如果是前序遍历，先将整个左子树拼接到右边，再去遍历整个右子树，整个右子树会拉得特别长，再一个个递归下去，这耗费的时间和空间就特别多了。而如果使用后序遍历，先遍历左右子树，分别把左右子树处理完成后，最后处理root节点，这样使用的时间和空间会少很多。即前序遍历是自顶向下的方法，而后序遍历是自底向上的方法，再通俗一点地说，对于这道题，使用后序遍历是使用归并的思想，先处理小的情况，最后把两边处理好的子树统一拼接起来，这样效率上会快很多。这个思路是递归的解法，迭代的解法可以去看官方解答。</p>
<br/>
<h3 id="填充每个节点的下一个右侧节点指针">
  填充每个节点的下一个右侧节点指针
  <a class="anchor" href="#%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88">#</a>
</h3>
<blockquote>
<p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
</blockquote>
<p>解析：</p>
<p>    这题同样也是想象一个最简单的情况，假设有这样一个前序遍历的二叉树，[1, 2, 3]，是不是非常简单，只需要把2节点的next指针指向3，即 left.Next = right。</p>
<p>    我们再延伸一层，比如题目中的例子，不仅左右子树各自next指针要赋值，它们之间的节点5的next要指向右子树的节点6，这应该怎么做呢？其实很简单，有点像简单题里的对称二叉树的遍历方式，只需要将 root.Left.Right 和 root.Right.Left 代入到上面的表达式 left.Next = right 中 left 和 right 中即可。即对于root来说，left是它的左子树，right是它的右子树，我们需要遍历 left.left，left.right、 left.right，right.left、right.left，right.right即可。</p>
<br/>
<h3 id="最大二叉树">
  最大二叉树
  <a class="anchor" href="#%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<blockquote>
<p>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>
<p>二叉树的根是数组 nums 中的最大元素。
左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
返回有给定数组 nums 构建的 最大二叉树 。</p>
</blockquote>
<p>解析：</p>
<p>    这题描述就告诉用递归了，那么还是考虑最简单情况，比如nums = [3,2,1]，我们先找到最大的值为3，索引为0，然后构造root节点，root.Left为3左边的部分，即递归参数为nums[:0]即空，root.Right的递归参数为nums[0:]，这样就行了，用递归很容易做出来。</p>
<br/>
<h3 id="从前序与中序遍历序列构造二叉树">
  从前序与中序遍历序列构造二叉树
  <a class="anchor" href="#%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong>
你可以假设树中没有重复的元素。</p>
</blockquote>
<p>解析：</p>
<p>    这类题先要找到根节点，再通过根节点找到左子树和右子树的两种遍历序列，作为参数递归下去构造二叉树即可。在这题里需要先通过前序遍历的根节点的值，找到中序遍历根节点的索引，再根据中序遍历找到左右子树的长度，即计算出从0到根节点的中序遍历数组的<strong>长度</strong>，或从根节点到数组末尾的<strong>长度</strong>。</p>
<br/>
<h3 id="从中序与后序遍历序列构造二叉树">
  从中序与后序遍历序列构造二叉树
  <a class="anchor" href="#%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<blockquote>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong>
你可以假设树中没有重复的元素。</p>
</blockquote>
<p>解析：</p>
<p>    和上道题类似，只不过后序遍历递归时，右子树区间是左子树的长度到后序遍历数组的长度-1。-1就是把root节点去掉。</p>
<br/>
<h3 id="寻找重复的子树">
  寻找重复的子树
  <a class="anchor" href="#%e5%af%bb%e6%89%be%e9%87%8d%e5%a4%8d%e7%9a%84%e5%ad%90%e6%a0%91">#</a>
</h3>
<blockquote>
<p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
</blockquote>
<p>解析：</p>
<p>    这题不是简单的遍历就能完成，它需要记录每个子树，然后再看是否重复，返回重复的子树。</p>
<p>    那么怎么记录子树呢？我们可以将二叉树序列化，其实只需要前序与后序遍历即可，即root.Val + &ldquo;,&rdquo; + left + &ldquo;,&rdquo; + right 或 left + &ldquo;,&rdquo; + right + &ldquo;,&rdquo; + root.Val，对于节点为nil我们返回&quot;#&quot;。但是不可以使用中序遍历来进行序列化，因为对于像下面这种情况，中序遍历的序列是一样的，但是对于题目来说这不是同一类的重复子树：</p>
<pre><code>   0           0
  /              \
 0							  0
</code></pre><p>中序遍历：#0#0# 和 #0#0#</p>
<p>前序遍历：00### 和 0#0##</p>
<p>后序遍历：##0#0   ###00</p>
<p>然后我们就可以将序列化的值存到map里，如果有重复就加入到结果数组中。</p>
<br/>
<h2 id="代码">
  代码
  <a class="anchor" href="#%e4%bb%a3%e7%a0%81">#</a>
</h2>
<h3 id="二叉树展开为链表-1">
  二叉树展开为链表
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e5%b1%95%e5%bc%80%e4%b8%ba%e9%93%be%e8%a1%a8-1">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)  {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> 
    }
    <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
    <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>
    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>

    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">left</span>
    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#66d9ef">nil</span>

    <span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">tmp</span> = <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Right</span>
    }
    <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">right</span>
}
</code></pre></div><br/>
<h3 id="填充每个节点的下一个右侧节点指针-1">
  填充每个节点的下一个右侧节点指针
  <a class="anchor" href="#%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88-1">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    }
    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> 
    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>
    <span style="color:#a6e22e">connectTwo</span>(<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">connectTwo</span>(<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">right</span>
        <span style="color:#a6e22e">connectTwo</span>(<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Right</span>)
        <span style="color:#a6e22e">connectTwo</span>(<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Left</span>)
        <span style="color:#a6e22e">connectTwo</span>(<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Right</span>)
    }
}
</code></pre></div><br/>
<h3 id="最大二叉树-1">
  最大二叉树
  <a class="anchor" href="#%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91-1">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">constructMaximumBinaryTree</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    }
    <span style="color:#a6e22e">maxIndex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">findMaxIndex</span>(<span style="color:#a6e22e">nums</span>)
    <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">maxIndex</span>]}
    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">constructMaximumBinaryTree</span>(<span style="color:#a6e22e">nums</span>[:<span style="color:#a6e22e">maxIndex</span>])
    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">constructMaximumBinaryTree</span>(<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">maxIndex</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findMaxIndex</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">max</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> <span style="color:#66d9ef">int</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">max</span> {
            <span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>]
            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">i</span>
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
}
</code></pre></div><br/>
<h3 id="从前序与中序遍历序列构造二叉树-1">
  从前序与中序遍历序列构造二叉树
  <a class="anchor" href="#%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91-1">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">preorder</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">inorder</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">preorder</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">inorder</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    }
    <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">preorder</span>[<span style="color:#ae81ff">0</span>]}
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">inorder</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">inorder</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">preorder</span>[<span style="color:#ae81ff">0</span>] {
            <span style="color:#a6e22e">index</span> = <span style="color:#a6e22e">i</span>
        }
    }
    <span style="color:#75715e">//前序遍历从1开始到左子树的长度，为左子树的前序遍历区间。+1是因为右边是开区间
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">preorder</span>[<span style="color:#ae81ff">1</span>:len(<span style="color:#a6e22e">inorder</span>[:<span style="color:#a6e22e">index</span>])<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">inorder</span>[:<span style="color:#a6e22e">index</span>])
    <span style="color:#75715e">//前序遍历从左子树的长度+1（即root节点）到末尾，即为右子树的前序遍历区间。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">preorder</span>[len(<span style="color:#a6e22e">inorder</span>[:<span style="color:#a6e22e">index</span>])<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:], <span style="color:#a6e22e">inorder</span>[<span style="color:#a6e22e">index</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
}
</code></pre></div><br/>
<h3 id="从中序与后序遍历序列构造二叉树-1">
  从中序与后序遍历序列构造二叉树
  <a class="anchor" href="#%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91-1">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">inorder</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">postorder</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">inorder</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">postorder</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    }
    <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">postorder</span>[len(<span style="color:#a6e22e">postorder</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]}
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">inorder</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">inorder</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Val</span> {
            <span style="color:#a6e22e">index</span> = <span style="color:#a6e22e">i</span>
            <span style="color:#66d9ef">break</span>
        }
    }
    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">inorder</span>[:<span style="color:#a6e22e">index</span>], <span style="color:#a6e22e">postorder</span>[:len(<span style="color:#a6e22e">inorder</span>[:<span style="color:#a6e22e">index</span>])])
    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">inorder</span>[<span style="color:#a6e22e">index</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:], <span style="color:#a6e22e">postorder</span>[len(<span style="color:#a6e22e">inorder</span>[:<span style="color:#a6e22e">index</span>]):len(<span style="color:#a6e22e">postorder</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
}
</code></pre></div><br/>
<h3 id="寻找重复的子树-1">
  寻找重复的子树
  <a class="anchor" href="#%e5%af%bb%e6%89%be%e9%87%8d%e5%a4%8d%e7%9a%84%e5%ad%90%e6%a0%91-1">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">treeMap</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findDuplicateSubtrees</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#a6e22e">res</span> = []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>{}
    <span style="color:#a6e22e">treeMap</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
    <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">string</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;#&#34;</span>
    }
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
    <span style="color:#a6e22e">str</span> = <span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Val</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">treeMap</span>[<span style="color:#a6e22e">str</span>]; <span style="color:#a6e22e">ok</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">v</span>)
        }
        <span style="color:#a6e22e">treeMap</span>[<span style="color:#a6e22e">str</span>] = <span style="color:#66d9ef">nil</span>
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#a6e22e">treeMap</span>[<span style="color:#a6e22e">str</span>] = <span style="color:#a6e22e">root</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>
}
</code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#二叉树中等题">二叉树中等题</a>
      <ul>
        <li><a href="#题目解析">题目解析</a>
          <ul>
            <li><a href="#二叉树展开为链表">二叉树展开为链表</a></li>
            <li><a href="#填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</a></li>
            <li><a href="#最大二叉树">最大二叉树</a></li>
            <li><a href="#从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</a></li>
            <li><a href="#从中序与后序遍历序列构造二叉树">从中序与后序遍历序列构造二叉树</a></li>
            <li><a href="#寻找重复的子树">寻找重复的子树</a></li>
          </ul>
        </li>
        <li><a href="#代码">代码</a>
          <ul>
            <li><a href="#二叉树展开为链表-1">二叉树展开为链表</a></li>
            <li><a href="#填充每个节点的下一个右侧节点指针-1">填充每个节点的下一个右侧节点指针</a></li>
            <li><a href="#最大二叉树-1">最大二叉树</a></li>
            <li><a href="#从前序与中序遍历序列构造二叉树-1">从前序与中序遍历序列构造二叉树</a></li>
            <li><a href="#从中序与后序遍历序列构造二叉树-1">从中序与后序遍历序列构造二叉树</a></li>
            <li><a href="#寻找重复的子树-1">寻找重复的子树</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












