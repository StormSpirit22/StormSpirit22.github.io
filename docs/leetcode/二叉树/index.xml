<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二叉树 on icestormspirit的博客</title>
    <link>https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
    <description>Recent content in 二叉树 on icestormspirit的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 22 May 2021 15:18:39 +0800</lastBuildDate><atom:link href="https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>二叉树遍历</title>
      <link>https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 27 Apr 2021 22:12:00 +0800</pubDate>
      
      <guid>https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树遍历 #   对于普通的二叉树遍历大家肯定都觉得这不是很简单吗，递归就解决了，但是对于基础还是要巩固一下。 前序遍历顺序：root节点，left节点，right节点。
中序遍历顺序：left节点，root节点，right节点。
后序遍历顺序：left节点，right节点，root节点。
可以看出前中后序其实就是root节点在哪个位置的遍历顺序。
另外还有层次遍历： 根据二叉树每一层的顺序来遍历。
 二叉树前序遍历 #   递归代码：
func preorderRecursive(root *TreeNode) []int { var res []int if root == nil { res = append(res, root.Val) res = append(res, preorderRecursive(root.Left)...) res = append(res, preorderRecursive(root.Right)...) } return res }  是不是很简单？但是非递归的代码能一口气写出来吗？非递归遍历需要借助栈来实现： func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var stack []*TreeNode for root != nil || len(stack) &amp;gt; 0 { for root !</description>
    </item>
    
    <item>
      <title>二叉树简单题</title>
      <link>https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E9%A2%98/</link>
      <pubDate>Sat, 22 May 2021 15:18:39 +0800</pubDate>
      
      <guid>https://StormSpirit22.github.io/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E9%A2%98/</guid>
      <description>二叉树简单题 #   上一篇文章里已经介绍了各种二叉树的遍历方式，可以看到对于二叉树来说，递归是最简洁并且好理解的遍历方式，所以对于二叉树的题，我们首先要想能不能用递归解决。而对于递归，我们不需要去考虑这个函数是否能实现我们要的功能，而是要相信函数一定能实现我们的功能，然后定义base case即可。学以致用，现在先来看看leetcode上二叉树的简单题，练练手。下面会先介绍这些题目的思路，ac代码集中放到最后。建议读者先自己去做一下想一想，然后手写代码，如果直接先看代码，没有经过自己的思考，第二次碰到可能还是不会做。
下面选取了一些题目，虽然是easy难度，但是如果是第一次做也是不容易能马上写出来的，所以还是要多刷题！^_^
 本文要介绍的题目有：
 二叉树的最大深度
 对称的二叉树
 二叉树的镜像
 二叉树的最近公共祖先
 平衡二叉树
 下面我们一个个来分析。
 二叉树的最大深度
 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
 解析：
这题比较简单，直接递归 max(left, right) + 1即可。
 对称的二叉树
 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
 解析：
要判断是不是对称二叉树，并不是简单地递归去判断左右子树的值是否相等，比如第一个例子，到第二层的时候就不是判断左右子树的值相等了，而是需要判断 left.left.val == right.right.val 和 left.right.val == right.left.val。那这怎么做呢？我们可以用一个辅助函数，参数值是 left, right， 每次只要判断 left.val 是否等于 right.val ，然后再将 left.left 和 right.right， left.right 和 right.left 递归就好了。
 二叉树的镜像
 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
 解析：
这题就是使用前序遍历，先将root左右子树节点交换，然后再继续遍历。
 二叉树的最近公共祖先
 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</description>
    </item>
    
  </channel>
</rss>
