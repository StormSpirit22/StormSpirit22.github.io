[{"id":0,"href":"/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","title":"二叉树遍历","section":"二叉树","content":"二叉树遍历 #   对于普通的二叉树遍历大家肯定都觉得这不是很简单吗，递归就解决了，但是对于基础还是要巩固一下。 前序遍历顺序：root节点，left节点，right节点。\n中序遍历顺序：left节点，root节点，right节点。\n后序遍历顺序：left节点，right节点，root节点。\n可以看出前中后序其实就是root节点在哪个位置的遍历顺序。\n另外还有层次遍历： 根据二叉树每一层的顺序来遍历。\n 二叉树前序遍历 #   递归代码：\nfunc preorderRecursive(root *TreeNode) []int { var res []int if root == nil { res = append(res, root.Val) res = append(res, preorderRecursive(root.Left)...) res = append(res, preorderRecursive(root.Right)...) } return res }  是不是很简单？但是非递归的代码能一口气写出来吗？非递归遍历需要借助栈来实现： func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var stack []*TreeNode for root != nil || len(stack) \u0026gt; 0 { for root != nil { result = append(result, root.Value) stack = append(stack, root) root = root.Left } node := stack[len(stack) - 1] stack = stack[:len(stack) - 1] root = node.Right } return result }  解释：因为是前序遍历，所以先将root值放入数组，然后深度遍历left节点，当left节点为null时，出栈，再将right节点赋值给root。比如有如下二叉树：  3 / \\ 9 20 / \\ / \\ 2 8 15 7 先遍历left节点将3、9、2入栈，此时result数组： [3, 9, 2]，接着stack出栈一个元素，node此时为2节点，root = node.right即为nil，接着下次循环，root = nil，直接出栈一个元素9， root 为节点8，接着循环，result数组就会变成[3, 9, 2, 8]，接着再出栈3， 循环遍历右子树，这样最后result数组的值就是前序遍历的最终结果：[3, 9, 2, 8, 20, 15, 7]。\n 二叉树中序遍历 #   递归代码：\nfunc inorderRecursive(root *TreeNode) []int { var res []int if root == nil { res = append(res, preorderRecursive(root.Left)...) res = append(res, root.Val) res = append(res, preorderRecursive(root.Right)...) } return res }  非递归代码：\nfunc inorderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var stack []*TreeNode for root != nil || len(stack) \u0026gt; 0 { for root != nil { stack = append(stack, root) root = root.Left } node := stack[len(stack) - 1] stack = stack[:len(stack) - 1] result = append(result, root.Value) root = node.Right } return result } 解释：就是把result append的位置换了一下。\n 二叉树后序遍历 #   递归代码：\nfunc postorderTraversal(root *TreeNode) []int { var res []int if root == nil { res = append(res, preorderRecursive(root.Left)...) res = append(res, preorderRecursive(root.Right)...) res = append(res, root.Val) } return res }  非递归代码：\nfunc postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var stack []*TreeNode var lastVisited *TreeNode for root != nil || len(stack) \u0026gt; 0 { for root != nil { stack = append(stack, root) root = root.Left } node := stack[len(stack) - 1] if node.Right == nil || node.Right == lastVisited { stack = stack[:len(stack) - 1] result = append(result, node.Value) lastVisited = node } else { root = node.Right } } return result }  解释：在前序和中序遍历中，遍历的顺序都是左根右，只需要将值加入数组的位置变化一下就行。但是后序遍历需要先访问左右子树的值，然后再访问根的值，但是在访问右子树之前，根节点就已经入栈了，解决方法是先获取栈顶节点但不出栈，看如果这个节点是叶子节点，那么出栈，或者不是叶子节点但它的右子树已经访问过了再出栈，这样访问顺序就是左右根了。所以后序遍历需要添加一个lastVisited的标记位，标记该节点已经遍历过。\n 层次遍历 #   递归代码：\nvar result [][]int func levelOrderRecursive(root *TreeNode) [][]int { if root == nil { return nil } levelOrderRecursiveHelper(root, 1) return result } func levelOrderRecursiveHelper(root *TreeNode, level int) { if root == nil { return } if len(result) \u0026lt; level { result = append(result, []int{}) } result[level-1] = append(result[level-1], root.Value) levelOrderRecursiveHelper(root.Left, level + 1) levelOrderRecursiveHelper(root.Right, level + 1) }  非递归代码： func levelOrderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var queue []*TreeNode queue = append(queue, root) for len(queue) \u0026gt; 0 { l := len(queue) for i := 0; i \u0026lt; l; i ++ { node := queue[0] queue = queue[1:] result = append(result, node.Value) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return result }  解释: 层次遍历递归解法借助了level参数来判断递归到哪一层。非递归解法就比较常规了，用队列来解决。本质上都是bfs算法。   总结： #  虽然二叉树遍历是最基础的，但是想完全掌握递归和非递归的解法还是需要一些时间的，大家都学废了吗？\n"},{"id":1,"href":"/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E9%A2%98/","title":"二叉树简单题","section":"二叉树","content":"二叉树简单题 #   上一篇文章里已经介绍了各种二叉树的遍历方式，可以看到对于二叉树来说，递归是最简洁并且好理解的遍历方式，所以对于二叉树的题，我们首先要想能不能用递归解决。而对于递归，我们不需要去考虑这个函数是否能实现我们要的功能，而是要相信函数一定能实现我们的功能，然后定义base case即可。学以致用，现在先来看看leetcode上二叉树的简单题，练练手。下面会先介绍这些题目的思路，ac代码集中放到最后。建议读者先自己去做一下想一想，然后手写代码，如果直接先看代码，没有经过自己的思考，第二次碰到可能还是不会做。\n下面选取了一些题目，虽然是easy难度，但是如果是第一次做也是不容易能马上写出来的，所以还是要多刷题！^_^\n 本文要介绍的题目有：\n 二叉树的最大深度\n 对称的二叉树\n 二叉树的镜像\n 二叉树的最近公共祖先\n 平衡二叉树\n 下面我们一个个来分析。\n 二叉树的最大深度\n 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n 解析：\n这题比较简单，直接递归 max(left, right) + 1即可。\n 对称的二叉树\n 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n 解析：\n要判断是不是对称二叉树，并不是简单地递归去判断左右子树的值是否相等，比如第一个例子，到第二层的时候就不是判断左右子树的值相等了，而是需要判断 left.left.val == right.right.val 和 left.right.val == right.left.val。那这怎么做呢？我们可以用一个辅助函数，参数值是 left, right， 每次只要判断 left.val 是否等于 right.val ，然后再将 left.left 和 right.right， left.right 和 right.left 递归就好了。\n 二叉树的镜像\n 请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n 解析：\n这题就是使用前序遍历，先将root左右子树节点交换，然后再继续遍历。\n 二叉树的最近公共祖先\n 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n 解析：\n我们在最开始就有说递归的思想就是要相信这个函数能实现我们的功能，然后定义base case。这题有几个base case需要判断，如果 root == nil 或 root == p 或 root == q，那么直接返回root，因为如果root是p或q中的任意一个节点，那么p、q的最近公共祖先肯定就是root。如果不是上述情况，那么p、q肯定在root的子树中。这样我们分别递归左右子树，返回的结果可以判断有三种情况，p、q都在root左子树中，则返回右子树的遍历结果，或者都在右子树中，返回左子树的遍历结果，或者p、q分别存在左右子树，则返回root。你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到。如果还是不理解，可以先看一下最后的代码，或者看一下官方的答案。\n 平衡二叉树\n 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n 解析：\n这题有两种解法，可以看题解。我这里选第二种解法来解释。我们可以先计算root节点的左子树的最大深度和右子树的最大深度，然后判断两者相差是否大于1，但是仅仅这样判断是不够的，因为你不知道左子树或者右子树里面会不会有深度相差大于1的情况，所以还需要继续递归左右子树去判断。\n 代码 #  二叉树的最大深度 #  func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b }  对称的二叉树 #  func isSymmetric(root *TreeNode) bool { if root == nil { return true } return helper(root.Left, root.Right) } func helper(l, r *TreeNode) bool { if l == nil \u0026amp;\u0026amp; r == nil { return true } if l == nil || r == nil || l.Val != r.Val { return false } return helper(l.Left, r.Right) \u0026amp;\u0026amp; helper(l.Right, r.Left) }  二叉树的镜像 #  func mirrorTree(root *TreeNode) *TreeNode { if root == nil || (root.Left == nil \u0026amp;\u0026amp; root.Right == nil) { return root } root.Left, root.Right = root.Right, root.Left mirrorTree(root.Left) mirrorTree(root.Right) return root }  二叉树的最近公共祖先 #  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left == nil { return right } return left }  平衡二叉树 #  func isBalanced(root *TreeNode) bool { if root == nil { return true } left := float64(depth(root.Left)) right := float64(depth(root.Right)) if math.Abs(left - right) \u0026gt; 1.0 { return false } return isBalanced(root.Left) \u0026amp;\u0026amp; isBalanced(root.Right) } func depth(root *TreeNode) int { if root == nil { return 0 } return max(depth(root.Left), depth(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } "},{"id":2,"href":"/docs/redis/Redis%E5%AD%A6%E4%B9%A0%E4%B8%80/","title":"Redis学习（一）","section":"Redis","content":"Redis 学习（一） #  redis想必大家都用过，但是一些底层实现的知识点还是需要好好看看，这篇博客就redis的数据结构为核心，总结网上的一些文章，当做学习笔记记录下来。侵删。\n一、Redis是什么？ #  Redis是一个开源的，基于内存的数据结构存储，可用作于数据库、缓存、消息中间件。redis的常用命令可以去查阅官网，这里不做介绍。\n二、为什么要用Redis #  Redis是基于内存的，用于缓存的一种技术。而且通常是以kv的方式进行存储的，有人就问了，为啥不用数据结构的map呢？map不也差不多？下面是几点原因：\n  数据结构的map是本地缓存，如果想用分布式缓存则做不到。多台机器缓存不具有一致性。\n  map是基于应用程序的，如果一个map特别大，那么运行起来会非常慢甚至程序会崩溃。而redis作为一个独立的缓存中间件，与应用程序解耦。\n  redis是专业做缓存的，不需要程序员去专门进行内存管理，而且可以将缓存数据存储到硬盘里，并且可以恢复，并且提供了多种数据结构及缓存过期等机制。\n  三、Redis的数据结构 #  Redis 有 5 种基础数据结构，它们分别是：string(字符串)、list(链表)、hash(哈希表)、set(集合) 和 zset(有序集合)。要说明的是，这些数据结构表示的是redis key-value中“value”的类型，redis的key都是字符串。而redis底层并不是直接使用这些类型，而是构造了一个redisObject的类型。也就是说，我们在redis里创建一个key-value，会至少创建出两个对象，key对象和value对象。redisObject数据结构：\ntypedef struct redisObject{ // 对象的类型 unsigned type 4:; // 对象的编码格式 unsigned encoding:4; // 指向底层实现数据结构的指针 void * ptr; //..... }robj;  （上面这张图现在看不懂没关系，等下面先介绍了几种数据结构再回过头来看就懂了。）\n简单来说就是Redis对key-value封装成对象，key是一个对象，value也是一个对象。每个对象都有type(类型)、encoding(编码)、ptr(指向底层数据结构的指针)来表示。\n下面分别就这几种类型的底层实现介绍一下。\n1、SDS #  redis是用c写的，但是redis的string并不是c里的string直接拿来用的。redis的string类型是一个叫做**简单动态字符串(Simple dynamic string,SDS)**的数据结构，源码如下：\nstruct sdshdr{ // 字节数组，用于保存字符串 char buf[]; // 记录buf数组中已使用的字节数量，也是字符串的长度 int len; // 记录buf数组未使用的字节数量 int free; } 可以看到sds的类型如图所示：\n 那么sds与c的string相比有何优化的地方呢？\n sdshdr数据结构中用len属性记录了字符串的长度。那么获取字符串的长度时，时间复杂度只需要O(1)。而c获取字符串长度都是O(N)的操作，每次都需要遍历整个数组。 SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(内部实现了动态扩展机制)。而对于c来说 SDS可以减少内存分配的次数(空间预分配机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(free 属性)。 SDS是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。  2、链表 #  链表这个数据结构大家应该也很熟悉了，在redis中的链表实现源码如下；\ntypedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; 可以看到，多个 listNode 可以通过 prev 和 next 指针组成双向链表：\n 使用listNode是可以组成链表了，Redis中使用list结构来持有链表：\ntypedef struct list{ //表头结点 listNode *head; //表尾节点 listNode *tail; //链表长度 unsigned long len; //节点值复制函数 void *(*dup) (viod *ptr); //节点值释放函数 void (*free) (viod *ptr); //节点值对比函数 int (*match) (void *ptr,void *key); }list 如下图所示：\n Redis的链表有以下特性： #   无环双向链表 获取表头指针，表尾指针，链表节点长度的时间复杂度均为O(1) 链表使用void *指针来保存节点值，可以保存各种不同类型的值  链表的基本操作 #   LPUSH 和 RPUSH 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素； LRANGE 命令可以从 list 中取出一定范围的元素； LINDEX 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 get(int index) 操作；  例子：\n\u0026gt; rpush mylist A (integer) 1 \u0026gt; rpush mylist B (integer) 2 \u0026gt; lpush mylist first (integer) 3 \u0026gt; lrange mylist 0 -1 # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有 1) \u0026quot;first\u0026quot; 2) \u0026quot;A\u0026quot; 3) \u0026quot;B\u0026quot; list实现队列：\n\u0026gt; RPUSH books python java golang (integer) 3 \u0026gt; LPOP books \u0026quot;python\u0026quot; \u0026gt; LPOP books \u0026quot;java\u0026quot; \u0026gt; LPOP books \u0026quot;golang\u0026quot; \u0026gt; LPOP books (nil) list实现栈：\n\u0026gt; RPUSH books python java golang (integer) 3 \u0026gt; LPOP books \u0026quot;python\u0026quot; \u0026gt; LPOP books \u0026quot;java\u0026quot; \u0026gt; LPOP books \u0026quot;golang\u0026quot; \u0026gt; LPOP books (nil) 3、哈希表 #  在Redis中，key-value的数据结构底层就是哈希表来实现的。Redis 中的哈希表相当于 Java 中的 HashMap，内部实现也差不多类似，都是通过 “数组 + 链表” 的链地址法来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。\nRedis的Hash类型通常用于存储对象数据，hash 类型很像一个关系型数据库的数据表，hash 的 Key 是一个唯一值，Value 部分是一个 hashmap 的结构。操作上可以用hget key field来得到value，或者hgetall key来得到该key下所有的field和对应的value。如图：\n 在Redis里边，哈希表使用dictht结构来定义：\n typedef struct dictht{ //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于size-1 unsigned long sizemark; //哈希表已有节点数量 unsigned long used; }dictht dictEntry结构：\n typedef struct dictEntry { //键 void *key; //值 union { void *value; uint64_tu64; int64_ts64; }v; //指向下个哈希节点，组成链表 struct dictEntry *next; }dictEntry; 哈希表最终dict结构：\ntypedef struct dict { //类型特定函数 dictType *type; //私有数据 void *privdata; //哈希表 dictht ht[2]; //rehash索引 //当rehash不进行时，值为-1 int rehashidx; }dict; //----------------------------------- typedef struct dictType{ //计算哈希值的函数 unsigned int (*hashFunction)(const void * key); //复制键的函数 void *(*keyDup)(void *private, const void *key); //复制值得函数 void *(*valDup)(void *private, const void *obj); //对比键的函数 int (*keyCompare)(void *privdata , const void *key1, const void *key2) //销毁键的函数 void (*keyDestructor)(void *private, void *key); //销毁值的函数 void (*valDestructor)(void *private, void *obj); }dictType 最后，redis的哈希表结构：\n 从代码实现和示例图上我们可以发现，Redis中有两个哈希表：\n ht[0]：用于存放真实的key-vlaue数据 ht[1]：用于扩容(rehash)  Rehash #  大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 小步搬迁：\n 渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。具体过程：\n (1:在字典中维持一个索引计数器变量rehashidx，并将设置为0，表示rehash开始。 (2:在rehash期间每次对字典进行增加、查询、删除和更新操作时，除了执行指定命令外；还会将ht[0]中rehashidx索引上的值rehash到ht[1]，操作完成后rehashidx+1。 (3:字典操作不断执行，最终在某个时间点，所有的键值对完成rehash，这时将rehashidx设置为-1，表示rehash完成 (4:在渐进式rehash过程中，字典会同时使用两个哈希表ht[0]和ht[1]，所有的更新、删除、查找操作也会在两个哈希表进行。例如要查找一个键的话，服务器会优先查找ht[0]，如果不存在，再查找ht[1]，诸如此类。此外当执行新增操作时，新的键值对一律保存到ht[1]，不再对ht[0]进行任何操作，以保证ht[0]的键值对数量只减不增，直至变为空表。  扩缩容的条件 #  正常情况下，当 hash 表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2 倍。不过如果 Redis 正在做 bgsave(持久化命令)，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。\n当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。\n4、压缩列表（ziplist） #  压缩列表(ziplist)是list和hash的底层实现之一。如果list的每个都是小整数值，或者是比较短的字符串，压缩列表(ziplist)作为list的底层实现。\n压缩列表(ziplist)是Redis为了节约内存而开发的，是由一系列的特殊编码的连续内存块组成的顺序性数据结构。压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间\n 节点的结构图：\n  压缩列表从表尾节点倒序遍历，首先指针通过zltail偏移量指向表尾节点，然后通过指向节点记录的前一个节点的长度依次向前遍历访问整个压缩列表。\n 5、跳跃表（skiplist) #  跳跃表(skiplist)是实现zset(有序集合)的底层数据结构之一，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的。\nskiplist由如下几个特点：\n 有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。 每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。 每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。 如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点  redis跳跃表具体的实现如图所示：\n 在跳跃表的结构中有head和tail表示指向头节点和尾节点的指针，能后快速的实现定位。level表示层数，len表示跳跃表的长度，BW表示后退指针，在从尾向前遍历的时候使用。\nBW下面还有两个值分别表示分值（score）和成员对象（各个节点保存的成员对象）。分值用来排序。跳跃表的实现中，除了最底层的一层保存的是原始链表的完整数据，上层的节点数会越来越少，并且跨度会越来越大。\n跳跃表的上面层就相当于索引层，都是为了找到最后的数据而服务的，数据量越大，条表所体现的查询的效率就越高，和平衡树的查询效率相差无几。\n6、整数集合（intset） #  整数集合是set(集合)的底层数据结构之一。当一个set(集合)只包含整数值元素，并且元素的数量不多时，Redis就会采用整数集合(intset)作为set(集合)的底层实现。\n整数集合(intset)保证了元素是不会出现重复的，并且是有序的(从小到大排序)，intset的结构是这样子的：\ntypeof struct intset { // 编码方式 unit32_t encoding; // 集合包含的元素数量 unit32_t lenght; // 保存元素的数组 int8_t contents[]; } intset; 示例图：\n 四、Redis五种数据结构的实现 #  回到开始的那张图：\n 可以看到在redis中，几种基本数据结构类型都有不同的编码方式，下面一一来分析一下。\n1、 字符串（String） #  在Redis中，你如果设置数字进去，比如set num 123，那么redis会以int来编码，在redis中会生成一个redisObject对象，如下图所示：\n 这个的意思是redis构造了一个类型为redis string、编码为int，指针指向123的对象。即上图的第一条。而如果你存储的不是数字类型，而是字符串类型，那么redis会使用前面介绍过的SDS方式进行存储，而这种方式有两种编码，如果字符串长度大于32字节，使用raw编码，否则使用embstr方式编码。\nembstr和raw都是由SDS动态字符串构成的。唯一区别是：raw是分配内存的时候，redisobject和 sds 各分配一块内存，而embstr是redisobject和raw在一块儿内存中。\nembstr和raw的区别：\n raw分配内存的时候，redisObject和SDS各分配一块内存，所以分配和释放内存的次数是两次。而embstr编码的数据是保存在一块连续的内存里，所以次数都是一次。  编码之间的转换：\n int类型如果存的不再是一个整数值，则会从int转成raw embstr是只读的，在修改的时候回从embstr转成raw  2、列表（List） #  在上面的图我们知道list类型有两种编码格式：\n ziplist：字符串元素的长度都小于64个字节\u0026amp;\u0026amp;总数量少于512个 linkedlist：字符串元素的长度大于64个字节||总数量大于512个  编码之间的转换：\n 原本是ziplist编码的，如果保存的数据长度太大或者元素数量过多，会转换成linkedlist编码的。  3、哈希（Hash） #  在上面的图我们知道hash类型有两种编码格式：\n ziplist：key和value的字符串长度都小于64字节\u0026amp;\u0026amp;键值对总数量小于512 hashtable：key和value的字符串长度大于64字节||键值对总数量大于512  编码之间的转换：\n 原本是ziplist编码的，如果保存的数据长度太大或者元素数量过多，会转换成hashtable编码的。  4、集合（Set） #  在上面的图我们知道set类型有两种编码格式：\n intset：保存的元素全都是整数\u0026amp;\u0026amp;总数量小于512 hashtable：保存的元素不是整数||总数量大于512  编码之间的转换：\n 原本是intset编码的，如果保存的数据不是整数值或者元素数量大于512，会转换成hashtable编码的。  5、有序集合（ZSet） #  在上面的图我们知道set类型有两种编码格式：\n ziplist：元素长度小于64\u0026amp;\u0026amp;总数量小于128 skiplist：元素长度大于64||总数量大于128  有序集合对象同时采用skiplist和哈希表来实现：\n skiplist能够达到插入的时间复杂度为O(logn)，根据成员查分值的时间复杂度为O(1)  编码之间的转换：\n 原本是ziplist编码的，如果保存的数据长度大于64或者元素数量大于128，会转换成skiplist编码的。  最后 #  没想到redis的数据结构就这么一大篇，还只是简单介绍，所以看起来平时特别常用的东西，其实内部实现光是学习也许要花不少时间的。之后会介绍redis其他的一些功能特性。\n参考 #   《【3y】从零单排学Redis【青铜】》 《Redis(1)——5种基本数据结构》\n"}]