[{"id":0,"href":"/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","title":"二叉树遍历","section":"二叉树","content":"二叉树遍历 #   对于普通的二叉树遍历大家肯定都觉得这不是很简单吗，递归就解决了，但是对于基础还是要巩固一下。 前序遍历顺序：root节点，left节点，right节点。\n中序遍历顺序：left节点，root节点，right节点。\n后序遍历顺序：left节点，right节点，root节点。\n可以看出前中后序其实就是root节点在哪个位置的遍历顺序。\n另外还有层次遍历： 根据二叉树每一层的顺序来遍历。\n 二叉树前序遍历 #   递归代码：\nfunc preorderRecursive(root *TreeNode) []int { var res []int if root == nil { res = append(res, root.Val) res = append(res, preorderRecursive(root.Left)...) res = append(res, preorderRecursive(root.Right)...) } return res }  是不是很简单？但是非递归的代码能一口气写出来吗？非递归遍历需要借助栈来实现： func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var stack []*TreeNode for root != nil || len(stack) \u0026gt; 0 { for root != nil { result = append(result, root.Value) stack = append(stack, root) root = root.Left } node := stack[len(stack) - 1] stack = stack[:len(stack) - 1] root = node.Right } return result }  解释：因为是前序遍历，所以先将root值放入数组，然后深度遍历left节点，当left节点为null时，出栈，再将right节点赋值给root。比如有如下二叉树：  3 / \\ 9 20 / \\ / \\ 2 8 15 7 先遍历left节点将3、9、2入栈，此时result数组： [3, 9, 2]，接着stack出栈一个元素，node此时为2节点，root = node.right即为nil，接着下次循环，root = nil，直接出栈一个元素9， root 为节点8，接着循环，result数组就会变成[3, 9, 2, 8]，接着再出栈3， 循环遍历右子树，这样最后result数组的值就是前序遍历的最终结果：[3, 9, 2, 8, 20, 15, 7]。\n 二叉树中序遍历 #   递归代码：\nfunc inorderRecursive(root *TreeNode) []int { var res []int if root == nil { res = append(res, preorderRecursive(root.Left)...) res = append(res, root.Val) res = append(res, preorderRecursive(root.Right)...) } return res }  非递归代码：\nfunc inorderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var stack []*TreeNode for root != nil || len(stack) \u0026gt; 0 { for root != nil { stack = append(stack, root) root = root.Left } node := stack[len(stack) - 1] stack = stack[:len(stack) - 1] result = append(result, root.Value) root = node.Right } return result } 解释：就是把result append的位置换了一下。\n 二叉树后序遍历 #   递归代码：\nfunc postorderTraversal(root *TreeNode) []int { var res []int if root == nil { res = append(res, preorderRecursive(root.Left)...) res = append(res, preorderRecursive(root.Right)...) res = append(res, root.Val) } return res }  非递归代码：\nfunc postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var stack []*TreeNode var lastVisited *TreeNode for root != nil || len(stack) \u0026gt; 0 { for root != nil { stack = append(stack, root) root = root.Left } node := stack[len(stack) - 1] if node.Right == nil || node.Right == lastVisited { stack = stack[:len(stack) - 1] result = append(result, node.Value) lastVisited = node } else { root = node.Right } } return result }  解释：在前序和中序遍历中，遍历的顺序都是左根右，只需要将值加入数组的位置变化一下就行。但是后序遍历需要先访问左右子树的值，然后再访问根的值，但是在访问右子树之前，根节点就已经入栈了，解决方法是先获取栈顶节点但不出栈，看如果这个节点是叶子节点，那么出栈，或者不是叶子节点但它的右子树已经访问过了再出栈，这样访问顺序就是左右根了。所以后序遍历需要添加一个lastVisited的标记位，标记该节点已经遍历过。\n 层次遍历 #   递归代码：\nvar result [][]int func levelOrderRecursive(root *TreeNode) [][]int { if root == nil { return nil } levelOrderRecursiveHelper(root, 1) return result } func levelOrderRecursiveHelper(root *TreeNode, level int) { if root == nil { return } if len(result) \u0026lt; level { result = append(result, []int{}) } result[level-1] = append(result[level-1], root.Value) levelOrderRecursiveHelper(root.Left, level + 1) levelOrderRecursiveHelper(root.Right, level + 1) }  非递归代码： func levelOrderTraversal(root *TreeNode) []int { if root == nil { return nil } var result []int var queue []*TreeNode queue = append(queue, root) for len(queue) \u0026gt; 0 { l := len(queue) for i := 0; i \u0026lt; l; i ++ { node := queue[0] queue = queue[1:] result = append(result, node.Value) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return result }  解释: 层次遍历递归解法借助了level参数来判断递归到哪一层。非递归解法就比较常规了，用队列来解决。本质上都是bfs算法。   总结 #  虽然二叉树遍历是最基础的，但是想完全掌握递归和非递归的解法还是需要一些时间的，大家都学废了吗？\n"},{"id":1,"href":"/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E9%A2%98/","title":"二叉树简单题","section":"二叉树","content":"二叉树简单题 #   上一篇文章里已经介绍了各种二叉树的遍历方式，可以看到对于二叉树来说，递归是最简洁并且好理解的遍历方式，所以对于二叉树的题，我们首先要想能不能用递归解决。而对于递归，我们不需要去考虑这个函数是否能实现我们要的功能，而是要相信函数一定能实现我们的功能，然后定义base case即可。学以致用，现在先来看看leetcode上二叉树的简单题，练练手。下面会先介绍这些题目的思路，ac代码集中放到最后。建议读者先自己去做一下想一想，然后手写代码，如果直接先看代码，没有经过自己的思考，第二次碰到可能还是不会做。\n下面选取了一些题目，虽然是easy难度，但是如果是第一次做也是不容易能马上写出来的，所以还是要多刷题！^_^\n 本文要介绍的题目有：\n 二叉树的最大深度\n 对称的二叉树\n 二叉树的镜像\n 二叉树的最近公共祖先\n 平衡二叉树\n下面我们一个个来分析。\n 题目解析 #  二叉树的最大深度 #   输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n 解析：\n 这题比较简单，直接递归 max(left, right) + 1即可。\n 对称的二叉树 #   请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n 解析：\n 要判断是不是对称二叉树，并不是简单地递归去判断左右子树的值是否相等，比如第一个例子，到第二层的时候就不是判断左右子树的值相等了，而是需要判断 left.left.val == right.right.val 和 left.right.val == right.left.val。那这怎么做呢？我们可以用一个辅助函数，参数值是 left, right， 每次只要判断 left.val 是否等于 right.val ，然后再将 left.left 和 right.right， left.right 和 right.left 递归就好了。\n 二叉树的镜像 #   请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n 解析：\n 这题就是使用前序遍历，先将root左右子树节点交换，然后再继续遍历。\n 二叉树的最近公共祖先 #   给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n 解析：\n 我们在最开始就有说递归的思想就是要相信这个函数能实现我们的功能，然后定义base case。\n 这题有几个base case需要判断，如果 root == nil 或 root == p 或 root == q，那么直接返回root，因为如果root是p或q中的任意一个节点，那么p、q的最近公共祖先肯定就是root。\n 如果不是上述情况，那么p、q肯定在root的子树中。这样我们分别递归左右子树，返回的结果可以判断有三种情况，p、q都在root左子树中，则返回右子树的遍历结果，或者都在右子树中，返回左子树的遍历结果，或者p、q分别存在左右子树，则返回root。\n 你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到。如果还是不理解，可以先看一下最后的代码，或者看一下官方的答案。\n 平衡二叉树 #   输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n 解析：\n 这题有两种解法，可以看题解。我这里选第二种解法来解释。我们可以先计算root节点的左子树的最大深度和右子树的最大深度，然后判断两者相差是否大于1，但是仅仅这样判断是不够的，因为你不知道左子树或者右子树里面会不会有深度相差大于1的情况，所以还需要继续递归左右子树去判断。\n 代码 #  二叉树的最大深度 #  func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b }  对称的二叉树 #  func isSymmetric(root *TreeNode) bool { if root == nil { return true } return helper(root.Left, root.Right) } func helper(l, r *TreeNode) bool { if l == nil \u0026amp;\u0026amp; r == nil { return true } if l == nil || r == nil || l.Val != r.Val { return false } return helper(l.Left, r.Right) \u0026amp;\u0026amp; helper(l.Right, r.Left) }  二叉树的镜像 #  func mirrorTree(root *TreeNode) *TreeNode { if root == nil || (root.Left == nil \u0026amp;\u0026amp; root.Right == nil) { return root } root.Left, root.Right = root.Right, root.Left mirrorTree(root.Left) mirrorTree(root.Right) return root }  二叉树的最近公共祖先 #  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left == nil { return right } return left }  平衡二叉树 #  func isBalanced(root *TreeNode) bool { if root == nil { return true } left := float64(depth(root.Left)) right := float64(depth(root.Right)) if math.Abs(left - right) \u0026gt; 1.0 { return false } return isBalanced(root.Left) \u0026amp;\u0026amp; isBalanced(root.Right) } func depth(root *TreeNode) int { if root == nil { return 0 } return max(depth(root.Left), depth(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } "},{"id":2,"href":"/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AD%89%E9%A2%98/","title":"二叉树中等题","section":"二叉树","content":"二叉树中等题 #  上次已经做完了二叉树的简单题，这次来看看难度为中等的题。首先有一个点需要讲清楚，就是二叉树的解法基本都是通过遍历，那么如何判断我们应该用前序还是中序还是后序遍历的框架？根据题意，思考一个二叉树节点需要做什么，到底用什么遍历顺序就清楚了。先看题，最好先点到题目里做一遍。\n本文要介绍的题目有：\n 二叉树展开为链表\n 填充每个节点的下一个右侧节点指针\n 最大二叉树\n 从前序与中序遍历序列构造二叉树\n 从中序与后序遍历序列构造二叉树\n 寻找重复的子树\n下面我们一个个来分析。\n 题目解析 #  二叉树展开为链表 #   给你二叉树的根结点 root ，请你将它展开为一个单链表：\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。\n 解析：\n 想象一个最简单的情况，对于一个root节点来说，假设它的左右子树都只有一个节点，那么把树展开为链表，应该是先把root.Right保存下来，然后root.Right = root.Left，最后遍历新的右子树到它的最右节点，然后把之前的右子树接上去，这一块逻辑应该比较清晰。\n 然后就是递归处理这一块代码就行了，有个问题就是这题用前序遍历还是后序呢？其实这两种都可以通过，区别在于需要的时间和空间不同，可以想象一下，如果是前序遍历，先将整个左子树拼接到右边，再去遍历整个右子树，整个右子树会拉得特别长，再一个个递归下去，这耗费的时间和空间就特别多了。而如果使用后序遍历，先遍历左右子树，分别把左右子树处理完成后，最后处理root节点，这样使用的时间和空间会少很多。即前序遍历是自顶向下的方法，而后序遍历是自底向上的方法，再通俗一点地说，对于这道题，使用后序遍历是使用归并的思想，先处理小的情况，最后把两边处理好的子树统一拼接起来，这样效率上会快很多。这个思路是递归的解法，迭代的解法可以去看官方解答。\n 填充每个节点的下一个右侧节点指针 #   给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n初始状态下，所有 next 指针都被设置为 NULL。\n 解析：\n 这题同样也是想象一个最简单的情况，假设有这样一个前序遍历的二叉树，[1, 2, 3]，是不是非常简单，只需要把2节点的next指针指向3，即 left.Next = right。\n 我们再延伸一层，比如题目中的例子，不仅左右子树各自next指针要赋值，它们之间的节点5的next要指向右子树的节点6，这应该怎么做呢？其实很简单，有点像简单题里的对称二叉树的遍历方式，只需要将 root.Left.Right 和 root.Right.Left 代入到上面的表达式 left.Next = right 中 left 和 right 中即可。即对于root来说，left是它的左子树，right是它的右子树，我们需要遍历 left.left，left.right、 left.right，right.left、right.left，right.right即可。\n 最大二叉树 #   给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：\n二叉树的根是数组 nums 中的最大元素。 左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。 右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。 返回有给定数组 nums 构建的 最大二叉树 。\n 解析：\n 这题描述就告诉用递归了，那么还是考虑最简单情况，比如nums = [3,2,1]，我们先找到最大的值为3，索引为0，然后构造root节点，root.Left为3左边的部分，即递归参数为nums[:0]即空，root.Right的递归参数为nums[0:]，这样就行了，用递归很容易做出来。\n 从前序与中序遍历序列构造二叉树 #   根据一棵树的前序遍历与中序遍历构造二叉树。\n注意: 你可以假设树中没有重复的元素。\n 解析：\n 这类题先要找到根节点，再通过根节点找到左子树和右子树的两种遍历序列，作为参数递归下去构造二叉树即可。在这题里需要先通过前序遍历的根节点的值，找到中序遍历根节点的索引，再根据中序遍历找到左右子树的长度，即计算出从0到根节点的中序遍历数组的长度，或从根节点到数组末尾的长度。\n 从中序与后序遍历序列构造二叉树 #   根据一棵树的中序遍历与后序遍历构造二叉树。\n注意: 你可以假设树中没有重复的元素。\n 解析：\n 和上道题类似，只不过后序遍历递归时，右子树区间是左子树的长度到后序遍历数组的长度-1。-1就是把root节点去掉。\n 寻找重复的子树 #   给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。\n两棵树重复是指它们具有相同的结构以及相同的结点值。\n 解析：\n 这题不是简单的遍历就能完成，它需要记录每个子树，然后再看是否重复，返回重复的子树。\n 那么怎么记录子树呢？我们可以将二叉树序列化，其实只需要前序与后序遍历即可，即root.Val + \u0026ldquo;,\u0026rdquo; + left + \u0026ldquo;,\u0026rdquo; + right 或 left + \u0026ldquo;,\u0026rdquo; + right + \u0026ldquo;,\u0026rdquo; + root.Val，对于节点为nil我们返回\u0026quot;#\u0026quot;。但是不可以使用中序遍历来进行序列化，因为对于像下面这种情况，中序遍历的序列是一样的，但是对于题目来说这不是同一类的重复子树：\n 0 0 / \\ 0\t0 中序遍历：#0#0# 和 #0#0#\n前序遍历：00### 和 0#0##\n后序遍历：##0#0 ###00\n然后我们就可以将序列化的值存到map里，如果有重复就加入到结果数组中。\n 代码 #  二叉树展开为链表 #  func flatten(root *TreeNode) { if root == nil { return } flatten(root.Left) flatten(root.Right) left := root.Left right := root.Right root.Right = left root.Left = nil tmp := root for tmp.Right != nil { tmp = tmp.Right } tmp.Right = right }  填充每个节点的下一个右侧节点指针 #  func connect(root *Node) *Node { if root == nil { return nil } left := root.Left right := root.Right connectTwo(left, right) return root } func connectTwo(left, right *Node) { if left != nil { left.Next = right connectTwo(left.Left, left.Right) connectTwo(left.Right, right.Left) connectTwo(right.Left, right.Right) } }  最大二叉树 #  func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) == 0 { return nil } maxIndex := findMaxIndex(nums) root := \u0026amp;TreeNode{Val: nums[maxIndex]} root.Left = constructMaximumBinaryTree(nums[:maxIndex]) root.Right = constructMaximumBinaryTree(nums[maxIndex+1:]) return root } func findMaxIndex(nums []int) int { max := -1 var res int for i := range nums { if nums[i] \u0026gt; max { max = nums[i] res = i } } return res }  从前序与中序遍历序列构造二叉树 #  func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 || len(inorder) == 0 { return nil } root := \u0026amp;TreeNode{Val: preorder[0]} var index int for i := range inorder { if inorder[i] == preorder[0] { index = i } } //前序遍历从1开始到左子树的长度，为左子树的前序遍历区间。+1是因为右边是开区间  root.Left = buildTree(preorder[1:len(inorder[:index])+1], inorder[:index]) //前序遍历从左子树的长度+1（即root节点）到末尾，即为右子树的前序遍历区间。  root.Right = buildTree(preorder[len(inorder[:index])+1:], inorder[index+1:]) return root }  从中序与后序遍历序列构造二叉树 #  func buildTree(inorder []int, postorder []int) *TreeNode { if len(inorder) == 0 || len(postorder) == 0 { return nil } root := \u0026amp;TreeNode{Val: postorder[len(postorder)-1]} var index int for i := range inorder { if inorder[i] == root.Val { index = i break } } root.Left = buildTree(inorder[:index], postorder[:len(inorder[:index])]) root.Right = buildTree(inorder[index+1:], postorder[len(inorder[:index]):len(postorder)-1]) return root }  寻找重复的子树 #  var treeMap map[string]*TreeNode var res []*TreeNode func findDuplicateSubtrees(root *TreeNode) []*TreeNode { res = []*TreeNode{} treeMap = make(map[string]*TreeNode) traverse(root) return res } func traverse(root *TreeNode) string { if root == nil { return \u0026#34;#\u0026#34; } var str string left := traverse(root.Left) right := traverse(root.Right) str = left + \u0026#34;,\u0026#34; + right + \u0026#34;,\u0026#34; + strconv.Itoa(root.Val) if v, ok := treeMap[str]; ok { if v != nil { res = append(res, v) } treeMap[str] = nil } else { treeMap[str] = root } return str } "},{"id":3,"href":"/docs/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E6%9D%82%E9%A2%98/","title":"二叉树复杂题","section":"二叉树","content":"二叉树复杂题 #  好了，二叉树的简单题、中等题我们都做过了一部分，基本的思路都了解了，这里看一下leetcode上的二叉树的复杂题，放心，只有一题。\n本文要介绍的题目有：\n 二叉树的序列化与反序列化\n下面我们来分析。\n 题目解析 #  二叉树的序列化与反序列化 #   序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n 解析：\n这道题更类似于设计题，可以先想想序列化怎么做，序列化我们之前在重复子树中已经做过类似的，这次是把整棵树都序列化，也大同小异。\n 先介绍递归的方法，使用前序遍历，我们假定如果节点为nil，则用“#”来代替，节点之间用“,”来分隔。我们需要一个变量data，当root == nil时，data += \u0026ldquo;#\u0026rdquo; + \u0026ldquo;,\u0026quot;，否则 data += root.Val，然后递归root.Left和root.Right，这样序列化就完成了。比如题目中的例子，root = [1,2,3,null,null,4,5]，序列化之后应该返回 “1,2,#,#,3,4,#,#,5,#,# ” 这样才对。\n 接着介绍反序列化，同样，我们需要声明一个全局变量nodes，作为strings.Split(data, \u0026ldquo;,\u0026quot;)的接收者，即将每个节点放到数组中，然后拿出数组第一个值，并在数组中去掉这个值，然后以这个值初始化root节点，接着使用nodes去递归赋值root.Left和root.Right即可。后序遍历也是可以的，大家可以自己去试试，但是中序遍历不行，因为中序遍历的序列化无法确定root值是哪个。\n 再介绍迭代的方法，也就是层次遍历，层次遍历就是借助队列来实现，序列化比较简单，这里跳过。要注意的是反序列化也需要借助队列，出队一个元素，需要再入队后面两个元素，即left，right。\n 代码 #  二叉树的序列化与反序列化（前序遍历） #  type Codec struct { } func Constructor() Codec { c := Codec{} return c } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { data := serializeHelper(root) data = data[:len(data)-1] return data } func serializeHelper(root *TreeNode) string { var data string if root == nil { data += \u0026#34;#\u0026#34; + \u0026#34;,\u0026#34; return data } data += strconv.Itoa(root.Val) + \u0026#34;,\u0026#34; data += serializeHelper(root.Left) data += serializeHelper(root.Right) return data } //需要一个全局变量nodes，如果helper是通过传值来进行nodes的传递，那么回溯时nodes应该被去掉的值没有被去掉， //而全局变量可以避免这个问题，或者在Codec结构体里声明一个nodes变量，helper作为成员函数也是可以的。 var nodes []string // Deserializes your encoded data to tree. func (this *Codec) deserialize(data string) *TreeNode { nodes = strings.Split(data, \u0026#34;,\u0026#34;) return deserializeHelper() } func deserializeHelper() *TreeNode { if len(nodes) == 0 { return nil } v := nodes[0] nodes = nodes[1:] if v == \u0026#34;#\u0026#34; { return nil } num, _ := strconv.Atoi(v) root := \u0026amp;TreeNode{Val: num} root.Left = deserializeHelper() root.Right = deserializeHelper() return root }  二叉树的序列化与反序列化（层次遍历） #  type Codec struct { } func Constructor() Codec { return Codec{} } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { if root == nil { return \u0026#34;\u0026#34; } var res string queue := list.New() queue.PushBack(root) for queue.Len() \u0026gt; 0 { n := queue.Len() for i := 0; i \u0026lt; n; i++ { tmp := queue.Front() tmpNode := tmp.Value.(*TreeNode) queue.Remove(tmp) if tmpNode == nil { res += \u0026#34;#,\u0026#34; } else { res += strconv.Itoa(tmpNode.Val) + \u0026#34;,\u0026#34; queue.PushBack(tmpNode.Left) queue.PushBack(tmpNode.Right) } } } res = res[:len(res)-1] return res } // Deserializes your encoded data to tree. func (this *Codec) deserialize(data string) *TreeNode { if len(data) == 0 { return nil } str := strings.Split(data, \u0026#34;,\u0026#34;) if len(str) == 0 { return nil } t, _ := strconv.Atoi(str[0]) root := \u0026amp;TreeNode{Val: t} queue := list.New() queue.PushBack(root) for i := 1; i \u0026lt; len(str); i++ { tmp := queue.Front() tmpNode := tmp.Value.(*TreeNode) queue.Remove(tmp) if str[i] != \u0026#34;#\u0026#34; { a, _ := strconv.Atoi(str[i]) tmpNode.Left = \u0026amp;TreeNode{Val: a} queue.PushBack(tmpNode.Left) } i++ if str[i] != \u0026#34;#\u0026#34; { a, _ := strconv.Atoi(str[i]) tmpNode.Right = \u0026amp;TreeNode{Val: a} queue.PushBack(tmpNode.Right) } } return root }  "},{"id":4,"href":"/docs/redis/Redis%E5%AD%A6%E4%B9%A0%E4%B8%80/","title":"Redis学习（一）","section":"Redis","content":"Redis 学习（一） #  redis想必大家都用过，但是一些底层实现的知识点还是需要好好看看，这篇博客就redis的数据结构为核心，总结网上的一些文章，当做学习笔记记录下来。侵删。\n一、Redis是什么？ #  Redis是一个开源的，基于内存的数据结构存储，可用作于数据库、缓存、消息中间件。redis的常用命令可以去查阅官网，这里不做介绍。\n二、为什么要用Redis #  Redis是基于内存的，用于缓存的一种技术。而且通常是以kv的方式进行存储的，有人就问了，为啥不用数据结构的map呢？map不也差不多？下面是几点原因：\n  数据结构的map是本地缓存，如果想用分布式缓存则做不到。多台机器缓存不具有一致性。\n  map是基于应用程序的，如果一个map特别大，那么运行起来会非常慢甚至程序会崩溃。而redis作为一个独立的缓存中间件，与应用程序解耦。\n  redis是专业做缓存的，不需要程序员去专门进行内存管理，而且可以将缓存数据存储到硬盘里，并且可以恢复，并且提供了多种数据结构及缓存过期等机制。\n  三、Redis的数据结构 #  Redis 有 5 种基础数据结构，它们分别是：string(字符串)、list(链表)、hash(哈希表)、set(集合) 和 zset(有序集合)。要说明的是，这些数据结构表示的是redis key-value中“value”的类型，redis的key都是字符串。而redis底层并不是直接使用这些类型，而是构造了一个redisObject的类型。也就是说，我们在redis里创建一个key-value，会至少创建出两个对象，key对象和value对象。redisObject数据结构：\ntypedef struct redisObject{ // 对象的类型 unsigned type 4:; // 对象的编码格式 unsigned encoding:4; // 指向底层实现数据结构的指针 void * ptr; //..... }robj;  （上面这张图现在看不懂没关系，等下面先介绍了几种数据结构再回过头来看就懂了。）\n简单来说就是Redis对key-value封装成对象，key是一个对象，value也是一个对象。每个对象都有type(类型)、encoding(编码)、ptr(指向底层数据结构的指针)来表示。\n下面分别就这几种类型的底层实现介绍一下。\n1、SDS #  redis是用c写的，但是redis的string并不是c里的string直接拿来用的。redis的string类型是一个叫做**简单动态字符串(Simple dynamic string,SDS)**的数据结构，源码如下：\nstruct sdshdr{ // 字节数组，用于保存字符串 char buf[]; // 记录buf数组中已使用的字节数量，也是字符串的长度 int len; // 记录buf数组未使用的字节数量 int free; } 可以看到sds的类型如图所示：\n 那么sds与c的string相比有何优化的地方呢？\n sdshdr数据结构中用len属性记录了字符串的长度。那么获取字符串的长度时，时间复杂度只需要O(1)。而c获取字符串长度都是O(N)的操作，每次都需要遍历整个数组。 SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(内部实现了动态扩展机制)。而对于c来说 SDS可以减少内存分配的次数(空间预分配机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(free 属性)。 SDS是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。  2、链表 #  链表这个数据结构大家应该也很熟悉了，在redis中的链表实现源码如下；\ntypedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; 可以看到，多个 listNode 可以通过 prev 和 next 指针组成双向链表：\n 使用listNode是可以组成链表了，Redis中使用list结构来持有链表：\ntypedef struct list{ //表头结点 listNode *head; //表尾节点 listNode *tail; //链表长度 unsigned long len; //节点值复制函数 void *(*dup) (viod *ptr); //节点值释放函数 void (*free) (viod *ptr); //节点值对比函数 int (*match) (void *ptr,void *key); }list 如下图所示：\n Redis的链表有以下特性： #   无环双向链表 获取表头指针，表尾指针，链表节点长度的时间复杂度均为O(1) 链表使用void *指针来保存节点值，可以保存各种不同类型的值  链表的基本操作 #   LPUSH 和 RPUSH 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素； LRANGE 命令可以从 list 中取出一定范围的元素； LINDEX 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 get(int index) 操作；  例子：\n\u0026gt; rpush mylist A (integer) 1 \u0026gt; rpush mylist B (integer) 2 \u0026gt; lpush mylist first (integer) 3 \u0026gt; lrange mylist 0 -1 # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有 1) \u0026quot;first\u0026quot; 2) \u0026quot;A\u0026quot; 3) \u0026quot;B\u0026quot; list实现队列：\n\u0026gt; RPUSH books python java golang (integer) 3 \u0026gt; LPOP books \u0026quot;python\u0026quot; \u0026gt; LPOP books \u0026quot;java\u0026quot; \u0026gt; LPOP books \u0026quot;golang\u0026quot; \u0026gt; LPOP books (nil) list实现栈：\n\u0026gt; RPUSH books python java golang (integer) 3 \u0026gt; LPOP books \u0026quot;python\u0026quot; \u0026gt; LPOP books \u0026quot;java\u0026quot; \u0026gt; LPOP books \u0026quot;golang\u0026quot; \u0026gt; LPOP books (nil) 3、哈希表 #  在Redis中，key-value的数据结构底层就是哈希表来实现的。Redis 中的哈希表相当于 Java 中的 HashMap，内部实现也差不多类似，都是通过 “数组 + 链表” 的链地址法来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。\nRedis的Hash类型通常用于存储对象数据，hash 类型很像一个关系型数据库的数据表，hash 的 Key 是一个唯一值，Value 部分是一个 hashmap 的结构。操作上可以用hget key field来得到value，或者hgetall key来得到该key下所有的field和对应的value。如图：\n 在Redis里边，哈希表使用dictht结构来定义：\n typedef struct dictht{ //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于size-1 unsigned long sizemark; //哈希表已有节点数量 unsigned long used; }dictht dictEntry结构：\n typedef struct dictEntry { //键 void *key; //值 union { void *value; uint64_tu64; int64_ts64; }v; //指向下个哈希节点，组成链表 struct dictEntry *next; }dictEntry; 哈希表最终dict结构：\ntypedef struct dict { //类型特定函数 dictType *type; //私有数据 void *privdata; //哈希表 dictht ht[2]; //rehash索引 //当rehash不进行时，值为-1 int rehashidx; }dict; //----------------------------------- typedef struct dictType{ //计算哈希值的函数 unsigned int (*hashFunction)(const void * key); //复制键的函数 void *(*keyDup)(void *private, const void *key); //复制值得函数 void *(*valDup)(void *private, const void *obj); //对比键的函数 int (*keyCompare)(void *privdata , const void *key1, const void *key2) //销毁键的函数 void (*keyDestructor)(void *private, void *key); //销毁值的函数 void (*valDestructor)(void *private, void *obj); }dictType 最后，redis的哈希表结构：\n 从代码实现和示例图上我们可以发现，Redis中有两个哈希表：\n ht[0]：用于存放真实的key-vlaue数据 ht[1]：用于扩容(rehash)  Rehash #  大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 小步搬迁：\n 渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。具体过程：\n (1:在字典中维持一个索引计数器变量rehashidx，并将设置为0，表示rehash开始。 (2:在rehash期间每次对字典进行增加、查询、删除和更新操作时，除了执行指定命令外；还会将ht[0]中rehashidx索引上的值rehash到ht[1]，操作完成后rehashidx+1。 (3:字典操作不断执行，最终在某个时间点，所有的键值对完成rehash，这时将rehashidx设置为-1，表示rehash完成 (4:在渐进式rehash过程中，字典会同时使用两个哈希表ht[0]和ht[1]，所有的更新、删除、查找操作也会在两个哈希表进行。例如要查找一个键的话，服务器会优先查找ht[0]，如果不存在，再查找ht[1]，诸如此类。此外当执行新增操作时，新的键值对一律保存到ht[1]，不再对ht[0]进行任何操作，以保证ht[0]的键值对数量只减不增，直至变为空表。  扩缩容的条件 #  正常情况下，当 hash 表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2 倍。不过如果 Redis 正在做 bgsave(持久化命令)，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。\n当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。\n4、压缩列表（ziplist） #  压缩列表(ziplist)是list和hash的底层实现之一。如果list的每个都是小整数值，或者是比较短的字符串，压缩列表(ziplist)作为list的底层实现。\n压缩列表(ziplist)是Redis为了节约内存而开发的，是由一系列的特殊编码的连续内存块组成的顺序性数据结构。压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间\n 节点的结构图：\n  压缩列表从表尾节点倒序遍历，首先指针通过zltail偏移量指向表尾节点，然后通过指向节点记录的前一个节点的长度依次向前遍历访问整个压缩列表。\n 5、跳跃表（skiplist) #  跳跃表(skiplist)是实现zset(有序集合)的底层数据结构之一，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的。\nskiplist由如下几个特点：\n 有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。 每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。 每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。 如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点  redis跳跃表具体的实现如图所示：\n 在跳跃表的结构中有head和tail表示指向头节点和尾节点的指针，能后快速的实现定位。level表示层数，len表示跳跃表的长度，BW表示后退指针，在从尾向前遍历的时候使用。\nBW下面还有两个值分别表示分值（score）和成员对象（各个节点保存的成员对象）。分值用来排序。跳跃表的实现中，除了最底层的一层保存的是原始链表的完整数据，上层的节点数会越来越少，并且跨度会越来越大。\n跳跃表的上面层就相当于索引层，都是为了找到最后的数据而服务的，数据量越大，条表所体现的查询的效率就越高，和平衡树的查询效率相差无几。\n6、整数集合（intset） #  整数集合是set(集合)的底层数据结构之一。当一个set(集合)只包含整数值元素，并且元素的数量不多时，Redis就会采用整数集合(intset)作为set(集合)的底层实现。\n整数集合(intset)保证了元素是不会出现重复的，并且是有序的(从小到大排序)，intset的结构是这样子的：\ntypeof struct intset { // 编码方式 unit32_t encoding; // 集合包含的元素数量 unit32_t lenght; // 保存元素的数组 int8_t contents[]; } intset; 示例图：\n 四、Redis五种数据结构的实现 #  回到开始的那张图：\n 可以看到在redis中，几种基本数据结构类型都有不同的编码方式，下面一一来分析一下。\n1、 字符串（String） #  在Redis中，你如果设置数字进去，比如set num 123，那么redis会以int来编码，在redis中会生成一个redisObject对象，如下图所示：\n 这个的意思是redis构造了一个类型为redis string、编码为int，指针指向123的对象。即上图的第一条。而如果你存储的不是数字类型，而是字符串类型，那么redis会使用前面介绍过的SDS方式进行存储，而这种方式有两种编码，如果字符串长度大于32字节，使用raw编码，否则使用embstr方式编码。\nembstr和raw都是由SDS动态字符串构成的。唯一区别是：raw是分配内存的时候，redisobject和 sds 各分配一块内存，而embstr是redisobject和raw在一块儿内存中。\nembstr和raw的区别：\n raw分配内存的时候，redisObject和SDS各分配一块内存，所以分配和释放内存的次数是两次。而embstr编码的数据是保存在一块连续的内存里，所以次数都是一次。  编码之间的转换：\n int类型如果存的不再是一个整数值，则会从int转成raw embstr是只读的，在修改的时候回从embstr转成raw  2、列表（List） #  在上面的图我们知道list类型有两种编码格式：\n ziplist：字符串元素的长度都小于64个字节\u0026amp;\u0026amp;总数量少于512个 linkedlist：字符串元素的长度大于64个字节||总数量大于512个  编码之间的转换：\n 原本是ziplist编码的，如果保存的数据长度太大或者元素数量过多，会转换成linkedlist编码的。  3、哈希（Hash） #  在上面的图我们知道hash类型有两种编码格式：\n ziplist：key和value的字符串长度都小于64字节\u0026amp;\u0026amp;键值对总数量小于512 hashtable：key和value的字符串长度大于64字节||键值对总数量大于512  编码之间的转换：\n 原本是ziplist编码的，如果保存的数据长度太大或者元素数量过多，会转换成hashtable编码的。  4、集合（Set） #  在上面的图我们知道set类型有两种编码格式：\n intset：保存的元素全都是整数\u0026amp;\u0026amp;总数量小于512 hashtable：保存的元素不是整数||总数量大于512  编码之间的转换：\n 原本是intset编码的，如果保存的数据不是整数值或者元素数量大于512，会转换成hashtable编码的。  5、有序集合（ZSet） #  在上面的图我们知道set类型有两种编码格式：\n ziplist：元素长度小于64\u0026amp;\u0026amp;总数量小于128 skiplist：元素长度大于64||总数量大于128  有序集合对象同时采用skiplist和哈希表来实现：\n skiplist能够达到插入的时间复杂度为O(logn)，根据成员查分值的时间复杂度为O(1)  编码之间的转换：\n 原本是ziplist编码的，如果保存的数据长度大于64或者元素数量大于128，会转换成skiplist编码的。  最后 #  没想到redis的数据结构就这么一大篇，还只是简单介绍，所以看起来平时特别常用的东西，其实内部实现光是学习也许要花不少时间的。之后会介绍redis其他的一些功能特性。\n参考 #   《【3y】从零单排学Redis【青铜】》 《Redis(1)——5种基本数据结构》\n"},{"id":5,"href":"/docs/leetcode/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/","title":"数组","section":"Leetcode","content":"数组 #    爱吃香蕉的珂珂：可以先用暴力循环，从1开始到数组最大值逐个遍历，如果需要时间小于h则返回。进一步向想是不是可以用二分法，l=1，r=max(array)+1，如果小于h则记录当时的mid值。  在 D 天内送达包裹的能力：同上，不过l=max(array)，r=sum(array)。  "}]